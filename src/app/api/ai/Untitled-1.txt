src/lib/ai/router.ts
typescriptimport Anthropic from '@anthropic-ai/sdk';
import { GoogleGenerativeAI } from '@google/generative-ai';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

const gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

export async function routeAIRequest(
  userPlan: string,
  prompt: string,
  type: 'chat' | 'code'
) {
  switch(userPlan) {
    case 'free':
      return generateBasicResponse(prompt, type);
      
    case 'medium':
      return generateGeminiResponse(prompt, type);
      
    case 'expert':
      return generateClaudeResponse(prompt, type);
      
    default:
      return generateBasicResponse(prompt, type);
  }
}

async function generateBasicResponse(prompt: string, type: string) {
  // AI Ø¨Ø³ÙŠØ· - Ø±Ø¯ÙˆØ¯ Ù…Ø­Ø¯ÙˆØ¯Ø©
  if (type === 'code') {
    return {
      code: `<!-- ÙƒÙˆØ¯ Ø¨Ø³ÙŠØ· -->\n<div>${prompt}</div>`,
      language: 'html'
    };
  }
  return { message: 'Ø±Ø¯ Ø¨Ø³ÙŠØ·: ' + prompt };
}

async function generateGeminiResponse(prompt: string, type: string) {
  const model = gemini.getGenerativeModel({ model: "gemini-pro" });
  
  const systemPrompt = type === 'code' 
    ? 'Ø£Ù†Øª Ù…Ø¨Ø±Ù…Ø¬ Ø®Ø¨ÙŠØ±. Ø§ÙƒØªØ¨ ÙƒÙˆØ¯ Ù†Ø¸ÙŠÙ ÙˆØ§Ø­ØªØ±Ø§ÙÙŠ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø´Ø±Ø­.'
    : 'Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ ÙˆÙ…ÙÙŠØ¯.';
    
  const result = await model.generateContent(systemPrompt + '\n\n' + prompt);
  const response = await result.response;
  
  if (type === 'code') {
    return {
      code: extractCode(response.text()),
      language: detectLanguage(prompt)
    };
  }
  
  return { message: response.text() };
}

async function generateClaudeResponse(prompt: string, type: string) {
  const systemPrompt = type === 'code'
    ? 'Ø£Ù†Øª Ø®Ø¨ÙŠØ± Ø¨Ø±Ù…Ø¬Ø© Ù…ØªÙ‚Ø¯Ù…. Ø§ÙƒØªØ¨ ÙƒÙˆØ¯ Ø§Ø­ØªØ±Ø§ÙÙŠ ÙƒØ§Ù…Ù„ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù….'
    : 'Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ù…ØªÙ‚Ø¯Ù….';
    
  const message = await anthropic.messages.create({
    model: "claude-sonnet-4-20250514",
    max_tokens: 4096,
    system: systemPrompt,
    messages: [{
      role: "user",
      content: prompt
    }]
  });
  
  const content = message.content[0];
  const text = content.type === 'text' ? content.text : '';
  
  if (type === 'code') {
    return {
      code: extractCode(text),
      language: detectLanguage(prompt)
    };
  }
  
  return { message: text };
}

function extractCode(text: string): string {
  const codeMatch = text.match(/```[\w]*\n([\s\S]*?)```/);
  return codeMatch ? codeMatch[1].trim() : text;
}

function detectLanguage(prompt: string): string {
  if (prompt.includes('react') || prompt.includes('jsx')) return 'jsx';
  if (prompt.includes('typescript') || prompt.includes('tsx')) return 'tsx';
  if (prompt.includes('css')) return 'css';
  if (prompt.includes('javascript') || prompt.includes('js')) return 'javascript';
  return 'html';
}

âœ… 1/5 Ø¬Ø§Ù‡Ø² - Ø§Ù„ØªØ§Ù„ÙŠØŸWiederholenØ§ØµØ§Ù„ØªØ§Ù„ÙŠğŸ”¥ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµØ¹Ø¨ 2/5

src/app/api/chat/route.ts
typescriptimport { NextRequest, NextResponse } from 'next/server';
import { routeAIRequest } from '@/lib/ai/router';
import { checkUsageLimit, incrementUsage } from '@/lib/subscription/checker';
import { getUserPlan } from '@/lib/subscription/checker';

export async function POST(req: NextRequest) {
  try {
    const { message, userId } = await req.json();
    
    if (!userId || !message) {
      return NextResponse.json({ error: 'Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©' }, { status: 400 });
    }
    
    // 1. ÙØ­Øµ Ø­Ø¯ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
    const canUse = await checkUsageLimit(userId);
    if (!canUse) {
      return NextResponse.json({ 
        error: 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ',
        upgrade: true 
      }, { status: 429 });
    }
    
    // 2. Ø¬Ù„Ø¨ Ø¨Ø§Ù‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const userPlan = await getUserPlan(userId);
    
    // 3. ØªÙˆØ¬ÙŠÙ‡ Ù„Ù„Ù€ AI Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
    const response = await routeAIRequest(userPlan, message, 'chat');
    
    // 4. ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
    await incrementUsage(userId);
    
    return NextResponse.json({ 
      response: response.message,
      plan: userPlan 
    });
    
  } catch (error) {
    console.error('Chat API Error:', error);
    return NextResponse.json({ error: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…' }, { status: 500 });
  }
}

âœ… 2/5 Ø¬Ø§Ù‡Ø² - Ø§Ù„ØªØ§Ù„ÙŠØŸWiederholenØ§ØµØ§Ù„ØªØ§Ù„ÙŠğŸ”¥ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµØ¹Ø¨ 3/5

src/app/api/code-gen/route.ts
typescriptimport { NextRequest, NextResponse } from 'next/server';
import { routeAIRequest } from '@/lib/ai/router';
import { checkUsageLimit, incrementUsage, getUserPlan } from '@/lib/subscription/checker';

export async function POST(req: NextRequest) {
  try {
    const { prompt, userId, currentCode } = await req.json();
    
    if (!userId || !prompt) {
      return NextResponse.json({ error: 'Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©' }, { status: 400 });
    }
    
    // 1. ÙØ­Øµ Ø§Ù„Ø­Ø¯
    const canUse = await checkUsageLimit(userId);
    if (!canUse) {
      return NextResponse.json({ 
        error: 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ',
        upgrade: true 
      }, { status: 429 });
    }
    
    // 2. Ø¬Ù„Ø¨ Ø§Ù„Ø¨Ø§Ù‚Ø©
    const userPlan = await getUserPlan(userId);
    
    // 3. Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø·Ù„Ø¨
    let fullPrompt = prompt;
    if (currentCode) {
      fullPrompt = `Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ:\n${currentCode}\n\nØ§Ù„Ø·Ù„Ø¨: ${prompt}`;
    }
    
    // 4. ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯
    const result = await routeAIRequest(userPlan, fullPrompt, 'code');
    
    // 5. ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
    await incrementUsage(userId);
    
    return NextResponse.json({
      code: result.code,
      language: result.language,
      plan: userPlan
    });
    
  } catch (error) {
    console.error('Code Gen Error:', error);
    return NextResponse.json({ error: 'Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯' }, { status: 500 });
  }
}

âœ… 3/5 Ø¬Ø§Ù‡Ø² - Ø§Ù„ØªØ§Ù„ÙŠØŸWiederholenØ§ØµØ§Ù„ØªØ§Ù„ÙŠğŸ”¥ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµØ¹Ø¨ 4/5

src/components/CodeEditor.tsx
typescript'use client';

import { useState, useEffect } from 'react';
import Editor from '@monaco-editor/react';

interface CodeEditorProps {
  code: string;
  language: string;
  onChange: (value: string) => void;
  readOnly?: boolean;
}

export default function CodeEditor({ 
  code, 
  language, 
  onChange,
  readOnly = false 
}: CodeEditorProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <div className="loading">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>;
  }

  return (
    <div className="code-editor">
      <div className="editor-header">
        <span className="language-badge">{language}</span>
        <button 
          onClick={() => navigator.clipboard.writeText(code)}
          className="copy-btn"
        >
          ğŸ“‹ Ù†Ø³Ø®
        </button>
      </div>
      
      <Editor
        height="100%"
        language={language}
        value={code}
        onChange={(value) => onChange(value || '')}
        theme="vs-dark"
        options={{
          readOnly,
          minimap: { enabled: false },
          fontSize: 14,
          lineNumbers: 'on',
          scrollBeyondLastLine: false,
          automaticLayout: true,
          tabSize: 2,
        }}
      />
    </div>
  );
}

âœ… 4/5 Ø¬Ø§Ù‡Ø² - Ø§Ù„ØªØ§Ù„ÙŠØŸWiederholenØ§ØµØ§Ù„ØªØ§Ù„ÙŠ  ÙˆØªÙˆÙ‚ÙğŸ”¥ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµØ¹Ø¨ 5/5

src/components/LivePreview.tsx
typescript'use client';

import { useEffect, useRef, useState } from 'react';

interface LivePreviewProps {
  code: string;
  language: string;
}

export default function LivePreview({ code, language }: LivePreviewProps) {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!iframeRef.current) return;

    try {
      const iframe = iframeRef.current;
      const document = iframe.contentDocument;
      
      if (!document) return;

      let html = '';
      
      if (language === 'html') {
        html = code;
      } else if (language === 'jsx' || language === 'tsx') {
        html = `
          <!DOCTYPE html>
          <html>
            <head>
              <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
              <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
              <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
            </head>
            <body>
              <div id="root"></div>
              <script type="text/babel">${code}</script>
            </body>
          </html>
        `;
      } else {
        html = `
          <!DOCTYPE html>
          <html>
            <head><style>${language === 'css' ? code : ''}</style></head>
            <body>
              <div id="preview">Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©</div>
              <script>${language === 'javascript' ? code : ''}</script>
            </body>
          </html>
        `;
      }

      document.open();
      document.write(html);
      document.close();
      
      setError(null);
      
    } catch (err) {
      setError('Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©');
      console.error(err);
    }
  }, [code, language]);

  return (
    <div className="live-preview">
      <div className="preview-header">
        <span>Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©</span>
        <button 
          onClick={() => iframeRef.current?.contentWindow?.location.reload()}
          className="refresh-btn"
        >
          ğŸ”„ ØªØ­Ø¯ÙŠØ«
        </button>
      </div>
      
      {error && <div className="error">{error}</div>}
      
      <iframe
        ref={iframeRef}
        className="preview-iframe"
        sandbox="allow-scripts"
        title="preview"
      />
    </div>
  );
}

âœ… 5/5 Ø¬Ø§Ù‡Ø²!